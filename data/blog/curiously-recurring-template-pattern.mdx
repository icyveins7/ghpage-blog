---
title: CRTP, method chaining, and static polymorphism
date: '2024-04-30'
tags: ['c++', 'crtp']
draft: false
summary: "Yes, it's yet another blogpost about CRTP and how it'd be useful.."
---

# The 1st issue: method chaining
Have you seen a billion other blogposts about CRTP? Yes, so have I. But maybe there's a reason for all of them; it wasn't really apparent when reading them previously why it would be useful and/or why I would ever need it. 


But recently, while writing some simple templated code for [```ufl```](https://github.com/icyveins7/ufl), I had the bright idea of trying to make method chaining possible for the class. That's when my templated class and its derived friend implementation started to fall apart. I fixed this by using CRTP for the first time.

I think [this post](https://dariusgrant.github.io/2021/02/11/Method-Chaining-Base-Class-Methods-With-Derived-Classes.html) is probably the best explanation for how CRTP solves this problem, so I'm not going to repeat it here, but rather leave a link (for myself). Bonus points for not having ads all over the place on that page.

# The 2nd issue: static polymorphism

I remember stumbling on a [video](https://www.youtube.com/watch?v=NH1Tta7purM) that removed virtual functions with templates a few years back. At the time, I didn't really grasp the concept very well (_is this what they call experience?_), but it's starting to dawn on me I think.

While writing some code for [```uhdeb```](https://github.com/icyveins7/uhdeb), I tried to wrap 2 similar but related streamer object classes in a container. I wanted a parent class that would hold a different type of streamer object - a ```tx_streamer``` or a ```rx_streamer``` - and to perform this initialization in the constructor (using another common object type that was passed in).

My first thought was to define a parent templated class that contained a ```T m_stream```. But now I had 2 choices:

1. I write a custom constructor for each of the derived classes. This would call the appropriate initialization for each type of ```m_stream```. But I wanted the constructor to also do similar things for both derived classes - allocate some memory, start a thread - and so I would have had to copy all those calls, violating DRY.

The code (roughly speaking) looked like this:

```
template <typename T>
class Parent
{
    ...

    T m_stream;
};

class DerivedRX : Parent<RXStreamer>
{
    DerivedRX(...) : Parent(...)
    {
        // create the RXStreamer..
        ...

        // the rest depend on the streamer, so I couldn't throw it into Parent's constructor
        allocate();
        start_thread();
    }
};

class DerivedTX : Parent<TXStreamer>
{
    DerivedTX(...) : Parent(...)
    {
        // create the TXStreamer..
        ...

        // the rest depend on the streamer, so I couldn't throw it into Parent's constructor
        allocate();
        start_thread();
    }
};
```

Could I have refactored the code to not have this problem? Probably. But at the time I was adamant on finding a way of getting this to work.


