---
title: "Esoteric Errors: 'hidden symbol is referenced by DSO'"
date: '2024-10-18'
tags: ['c++', 'gcc', 'build', 'errors', 'linker']
draft: false
summary: "Hidden linkage isn't something I'd encountered until now, so maybe this will help someone else too.."
---

# A new series of posts

I recently started work on a new codebase - one that is very large and has multiple moving components, from a frontend desktop UI (not my business) to the hardware interface (also not my business) and the backend processing (this one's my business).

The standard build process had been setup on a remote server, and most people were ok with the process of connecting to it with tangible amounts of latency, but I was not. So my stubborn ass decided to figure out how to build it myself on a local machine. In the process, I encountered a ridiculous number of build errors; they were using custom Makefiles, but they had been generated by some other tool (possibly from Windows, even though it was being built in Linux, since there was a Windows VS solution as well).

This will be the beginning of a series where I will document these errors for myself (and hopefully for others!).

# Topic for today

Alright enough backstory. The error being discussed here goes something like this:

```
hidden symbol X in Y is referenced by DSO
```

GCC (or rather, the linker) spat this out at me when it was trying to link in a Boost static library.

# It's _not_ an undefined reference

You'll be forgiven for thinking so, because that's what came to mind at first. But no, it's in the description; the symbol was there in the `.a` archive (an `nm` and `objdump` confirmed this).

This was a different kind of error, and one that I think resulted from the choice to build multiple parts of the code into separate shared library objects (`.so`s).

If you want to go ahead and read the stackoverflow links that helped me, go ahead and click [here](https://stackoverflow.com/questions/23696585/what-does-exactly-the-warning-mean-about-hidden-symbol-being-referenced-by-dso).

TODO: one more link?

# It's also not a link order issue

You'll again be forgiven for thinking this might have been the cause. This was what I tried at first to reproduce the problem in a simple scenario.

For those who don't know, `ld` resolves symbol references in a very specific order:

1. A compilation unit needs a particular symbol.
2. Libraries specified ***after*** that compilation unit provide this symbol.
3. Linker does its thing.

This is why specifying libraries in the right order matters, because if you provide the library '*before*' you make the 'request', the `ld` will not go back and get it for you (but I think MSVC will, so 1 point to Microsoft I guess?).

I'll leave this excellent writeup on the topic [here](https://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking), as I think it explains the topic far better than I ever could (he even talks about the circular dependencies! I had to do relist libraries during my build process fixes too!)

## A little more in-depth: what does the linker actually pull in?

What I tried to do to reproduce the `hidden symbol` issue at first was to create the following scenario:

1. Compile two separate source files separately: we'll call them `static.cpp` and `static_exclude.cpp` for reasons that will become apparent. They will share the same header, `static.h`, and we will place them all into the same static library.

```cpp
// static.h
int addstatic(int a, int b);
int notinshared(int a, int b);
float exclude(float a, float b);

// static.cpp
#include "static.h"

int addstatic(int a, int b){
  return a+b;
}

int notinshared(int a, int b){
  return a-b;
}

// static_exclude.cpp
#include "static.h"

float exclude(float a, float b){
  return a/b;
}
```

Honestly, I don't know how to write raw Makefiles (I'm more of a CMake dude), so I had ChatGPT spit one out for me:

```make
STATIC_LIB = libstatic.a

# Compile static.cpp to a static library (.a)
$(STATIC_LIB): $(STATIC_SRC)
	$(CXX) $(CXXFLAGS) -c static.cpp -o static.o
	$(CXX) $(CXXFLAGS) -c static_exclude.cpp -o static_exclude.o
	ar rcs $@ static.o static_exclude.o
```

So we made our `libstatic.a`.

> Fun fact: doing this taught me that Makefiles *must* use tabs in the recipe, not spaces!

2. Now we make a shared library from `shared.cpp`. This will use some functions from the static library we just made.

```cpp
// shared.h
int sharedaddscale(int a, int b, int c);

// shared.cpp
#include "shared.h"
#include "static.h"

int sharedaddscale(int a, int b, int c){
  return addstatic(a,b)*c;
}
```

And another excerpt from ChatGPT:

```make
SHARED_OBJ = shared.o
SHARED_LIB = libshared.so

# Compile shared.cpp to an object file
$(SHARED_OBJ): $(SHARED_SRC)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Link shared.o and static library to create the shared object (.so)
$(SHARED_LIB): $(SHARED_OBJ) $(STATIC_LIB)
	$(CXX) -shared -o $@ $(SHARED_OBJ) -L. -lstatic
```

This makes `libshared.so`.

3. Finally, we create our main executable file `e.cpp`.

```cpp
#include "static.h"
#include "shared.h"
#include <iostream>

int main(){

  printf("%d\n", sharedaddscale(2,3,4));
  printf("%d\n", notinshared(5,3));
  printf("%d\n", exclude(5.0f,3.0f));

  return 0;
}
```

And we link our shared library to it:

```make
E_SRC = e.cpp
E_OBJ = e.o
EXEC = final_executable

# Compile e.cpp to an object file
$(E_OBJ): $(E_SRC)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Link e.o with the shared library to create the final executable
$(EXEC): $(E_OBJ) $(SHARED_LIB)
	$(CXX) -o $@ $(E_OBJ) -L. -lshared
```

The question for you now is: does this build? If not, which function calls will cause errors?

You can ponder the code and build paths above before continuing down..

...

...

...

...

...

...

...

...

...

...

...

...

...

Alright that's enough blank space. If you said *only `exclude()`* will cause issues, then you would be correct, so congratulations! You're a qualified GCC nerd.

## Why does `exclude()` cause an undefined reference?

When the linker finds a symbol reference, it searches the later inputs to try to find it. Here, we only linked the shared library, so the next question must be: why is `exclude()` not inside the shared library? Didn't we link the static library when we created it?

The answer is that the linker resolves and includes only symbol definitions that it *requires*. The shared library never needed `exclude()`, so it never got included in the final output.

## Okay, but the shared library also didn't need `notinshared()`, so why is it there?

The above answer isn't technically complete. What the linker does exactly is to find a symbol reference it requries, and then *include the entire object file*. It doesn't matter whether it is a simple `.o`, or an archive (static library `.a`) of object files.

In the above example, we did need `addstatic()` inside `shared.cpp`. But `addstatic()` shares the same compilation unit (and hence the same object file) as `notinshared()` - both come from `static.cpp` which became `static.o` - so both of them end up inside the final shared library!

> Static libraries are basically just containers of object files to the linker.

[This](https://stackoverflow.com/questions/54126641/symbols-in-static-library-sometimes-got-linked-into-executable-sometimes-not) is a pretty good post about the above linkage behaviour.

# Back to the *real* topic of hidden references



